<!DOCTYPE html><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin=""><link href="https://fonts.googleapis.com/css2?family=Barlow:wght@200;400&family=Bitter&family=Inconsolata&display=swap" rel=stylesheet><link rel=icon type=image/svg+xml href=/notcodinglogo-filled.svg><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/atom-one-light.css><meta name=viewport content="width=device-width,initial-scale=1"><title>Understanding Strings and slices in Rust //notcoding.today</title><header><img src=/notcodingtoday.svg alt=//notcoding.today><hr><div class=navigation><a href=/about>About</a> <a href=/ >Blog</a></div><hr></header><div class=blog><h1>Understanding Strings and slices in Rust</h1><div class=center>2021-06-22</div><h2 id=strings>Strings?</h2><p>I was reading through Rust&#39;s excellent <a href=https://doc.rust-lang.org/stable/book/ >official book</a> to study Rust for the first time. Chapter <a href=https://doc.rust-lang.org/book/ch04-03-slices.html>04-03</a> of the book covers the <code>slice</code> type in Rust.<p>I did not manage to understand <code>String</code> in Rust with the contents of the book itself. Never in my life I had spent this much time to understand <code>String</code> in a language.<h2 id=reference-is-a-type-of-its-own><code>reference</code> is a type of its own</h2><p>My first question after reading the chapter was: how does making <code>slice</code> into <code>&amp;slice</code> suddenly make it bear length information?<p>To make this easier to swallow <a href=https://doc.rust-lang.org/std/primitive.reference.html>reference</a> itself is a unique primitive type in Rust. This made it easy for me to accept the fact that <code>&amp;T</code> can implement different properties to <code>T</code> (ex. <code>str</code> does not implement trait <code>Sized</code> but <code>&amp;str</code> does).<h2 id=slice--array-data-in-slice-is-from-an-array><code>slice</code> != <code>array</code>, data in <code>slice</code> is from an <code>array</code></h2><p>Both are primitive types in Rust and sound similar, but they are two different concepts.<p><a href=https://doc.rust-lang.org/std/primitive.slice.html><code>slice</code></a> is a &#39;contiguous block of memory of type <code>T</code>&#39;, and has no compile time definition. <a href=https://doc.rust-lang.org/std/primitive.array.html><code>array</code></a> is a fixed-size array, with compile time size.<p>Think of <code>slice</code> as &quot;a contiguous subset of an array&quot;. <code>slice</code> itself is purely conceptual and data itself actually comes from an <code>array</code>.<pre><code class=language-rust><span class=hljs-comment>// This is an array, not a slice. You can think of them as C-style arrays.</span>
<span class=hljs-keyword>let</span> arr: [<span class=hljs-built_in>u8</span>; <span class=hljs-number>3</span>] = [<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>];
<span class=hljs-comment>// This is a reference to a slice.</span>
<span class=hljs-keyword>let</span> slice: &amp;[<span class=hljs-built_in>u8</span>]: &amp;arr[..];
</code></pre><h2 id=str-is-literally-u8-with-utf-8-value-checking><code>str</code> is literally <code>[u8]</code> with UTF-8 value checking</h2><p><code>[u8]</code> == contiguous block of memory (slice) of type <code>u8</code>. <code>str</code> is essentially <code>[u8]</code> but has UTF-8 boundary checks built-in. <code>String</code> is essentially <code>str</code>, but not a conceptual contiguous subset of an array, but a real one.<h2 id=slice-makes-array-adhere-to-rusts-ownership-rules><code>slice</code> makes <code>array</code> adhere to Rust&#39;s ownership rules</h2><p>Why does <code>slice</code> exist?<p>The book it covers how to get n-th word in a String. Imagine writing such thing in C, you probably will write a function that returns start and end <code>char*</code>. If, for any reason, the original <code>char</code> array is freed from the heap, then using those pointers would cause problems.<p>Concept of subset of array (slice) prevents this - having a <em>reference</em> to <code>slice</code> (subset of array) will ensure the following code does not compile thanks to Rust&#39;s ownership rules:<pre><code class=language-rust><span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>first_word</span></span>(s: &amp;<span class=hljs-built_in>String</span>) -&gt; &amp;<span class=hljs-built_in>str</span> {
    <span class=hljs-keyword>let</span> bytes = s.as_bytes();

    <span class=hljs-keyword>for</span> (i, &amp;item) <span class=hljs-keyword>in</span> bytes.iter().enumerate() {
        <span class=hljs-keyword>if</span> item == <span class=hljs-string>b&#x27; &#x27;</span> {
            <span class=hljs-keyword>return</span> &amp;s[<span class=hljs-number>0</span>..i];
        }
    }

    &amp;s[..]
}

<span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>main</span></span>() {
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut</span> s = <span class=hljs-built_in>String</span>::from(<span class=hljs-string>&quot;hello world&quot;</span>);

    <span class=hljs-comment>// if this was just index(es), will compile</span>
    <span class=hljs-keyword>let</span> word = first_word(&amp;s);

    <span class=hljs-comment>// Reference to slice (subset of array) is tied to the original </span>
    <span class=hljs-comment>// array, so compiler will throw error if you do any illegal </span>
    <span class=hljs-comment>// things with references.</span>
    s.clear();  <span class=hljs-comment>// error!</span>

    <span class=hljs-built_in>println!</span>(<span class=hljs-string>&quot;the first word is: {}&quot;</span>, word);
}
</code></pre><p>If we only had arrays and had to follow Rust&#39;s ownership rules, we would be making copies around all the time, which would be expensive.<h2 id=putting-it-all-together>Putting it all together</h2><p><code>slice</code> is a contiguous subset of <code>array</code>. <code>str</code> is essentially <code>[u8]</code>. <code>slice</code> exist to help <code>array</code> follow Rust ownership rules.<p>Think of <code>slice</code> like pointer to an existing <code>array</code>, but you are not allowed to use the pointer by itself. Note: <code>slice</code> is not a pointer, it is a unique primitive type of its own.<p>From my understanding, <code>String</code> was created so that we can treat it like a <code>slice</code> but provide easy way for engineers to declare strings. Don&#39;t quote me on this part :P<h2 id=my-honest-review-of-rust-so-far>My honest review of Rust so far</h2><p>I am very impressed by how well-written the book is and great documentation. I am having tremendously better experience learning Rust compared to learning Vulkan.<p>I am not 100% convinced Rust-way to code is superior to traditional C-style. It feels like we just transformed the problems of C (memory management) into another shape (ownership). I, at this point in time, cannot comment if that is true nor optimal.</div><footer><hr><p>2020-2023 Copyright. All Rights Reserved.</footer>